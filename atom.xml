<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>onedream的博客</title>
  
  
  <link href="https://onedream666.github.io/atom.xml" rel="self"/>
  
  <link href="https://onedream666.github.io/"/>
  <updated>2021-02-28T12:21:18.074Z</updated>
  <id>https://onedream666.github.io/</id>
  
  <author>
    <name>zjw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础</title>
    <link href="https://onedream666.github.io/2021/02/28/java%E5%9F%BA%E7%A1%80/"/>
    <id>https://onedream666.github.io/2021/02/28/java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-02-28T12:16:48.000Z</published>
    <updated>2021-02-28T12:21:18.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><p>==（实时更新）==</p><h2 id="一-Collection"><a href="#一-Collection" class="headerlink" title="一.Collection"></a>一.Collection</h2><p>(可以用集合工具类Collections)</p><p><img src="/2021/02/28/java%E5%9F%BA%E7%A1%80/image-20210228163115330.png" alt="image-20210228163115330"></p><p>基本方法</p><p><strong><img src="/2021/02/28/java%E5%9F%BA%E7%A1%80/image-20210228163229405.png" alt="image-20210228163229405"></strong></p><h3 id="1-list"><a href="#1-list" class="headerlink" title="1.list"></a>1.list</h3><h4 id="Arraylist"><a href="#Arraylist" class="headerlink" title="Arraylist"></a>Arraylist</h4><p>查询快，增删慢,底层数组</p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>查询慢，增删快,底层链表</p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>同步单线程，没有collection快</p><h3 id="2-set"><a href="#2-set" class="headerlink" title="2.set"></a>2.set</h3><p>不包含重复的元素，哈希表结构</p><h4 id="Hashset"><a href="#Hashset" class="headerlink" title="Hashset"></a>Hashset</h4><p>==哈希表==jdk1.8之前数组+链表jdk1.8之后数组+红黑树（查询快）</p><p>==无序==</p><p><img src="/2021/02/28/java%E5%9F%BA%E7%A1%80/image-20210228192417526.png" alt="image-20210228192417526"></p><p>set集合调用add时候调用hashcode和equals方法判断是否重复</p><p>hashcode没有相同的就放入数组中，再判断equals是否相等，不等面值就会挂到数组下面的链表上（超过8个才会变成红黑树）</p><h4 id="Linkedhashset"><a href="#Linkedhashset" class="headerlink" title="Linkedhashset"></a>Linkedhashset</h4><p>底层哈希表+链表（用来记录元素的存储顺序）</p><p>==有序==不允许重复</p><h3 id="3-map"><a href="#3-map" class="headerlink" title="3.map"></a>3.map</h3><p>key-value 通过键找到值 key不允许重复</p><p>当map集合一创建，那么map集合创建一个entry对象,=表示键值关系</p><p>entryset获取key和value</p><h5 id="hashtablejdk1-0的被代替"><a href="#hashtablejdk1-0的被代替" class="headerlink" title="hashtablejdk1.0的被代替"></a>hashtablejdk1.0的被代替</h5><p>一些代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Arraylist</span></span><br><span class="line">        List&lt;String&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;5645&quot;</span>);</span><br><span class="line">        list.add(<span class="number">2</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.remove(<span class="number">1</span>);</span><br><span class="line">        list.set(<span class="number">2</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LinkedList</span></span><br><span class="line">        List&lt;String&gt; linkedList=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        linkedList.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        ((LinkedList&lt;String&gt;) linkedList).addFirst(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        ((LinkedList&lt;String&gt;) linkedList).push(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(((LinkedList&lt;String&gt;) linkedList).getFirst());</span><br><span class="line">        ((LinkedList&lt;String&gt;) linkedList).pop();</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//set</span></span><br><span class="line">        Set&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">8</span>);</span><br><span class="line">        set.add(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span>(Integer i:set)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LinkedHashSet</span></span><br><span class="line">        Set&lt;Integer&gt; linkedHashSet=<span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        linkedHashSet.add(<span class="number">3</span>);</span><br><span class="line">        linkedHashSet.add(<span class="number">8</span>);</span><br><span class="line">        linkedHashSet.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(linkedHashSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//HashMap</span></span><br><span class="line">        Map map=<span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.remove(<span class="number">1</span>));</span><br><span class="line">        System.out.println(map.get(<span class="number">2</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,Integer&gt;&gt;set1 = map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; it=set1.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;Integer,Integer&gt; entry=it.next();</span><br><span class="line">            System.out.print(entry.getKey());</span><br><span class="line">            System.out.print(entry.getValue());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二-String"><a href="#二-String" class="headerlink" title="二.String"></a>二.String</h2><p><strong>String：适用于少量的字符串操作的情况</strong>（只有string不可变）</p><p><strong>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</strong>（速度最快）</p><p><strong>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</strong></p><h2 id="三-树"><a href="#三-树" class="headerlink" title="三.树"></a>三.树</h2><ol><li>二叉树：分支不超过两个</li><li>排序树： 左子树小右子树大</li><li>平衡树： 左孩子和右孩子相等</li><li>红黑树：接近于平衡树，查询速度快，查找叶子节点最大次数和最小次数不超过2倍</li></ol><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="==红黑树=="></a>==红黑树==</h4><ol><li><p>节点可以是红色的或者黑色的</p></li><li><p>根节点是黑色的</p></li><li><p>叶子节点是黑色的</p></li><li><p>每个红色节点的子节点是黑色的</p></li><li><p>任何一个节点到每一个叶子节点的所有路径上黑色节点数相同</p></li></ol><h2 id="四-…"><a href="#四-…" class="headerlink" title="四. …"></a>四. …</h2><p>三个点表示函数可以传多个参数（参数个数不确定）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> ...arr)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</span><br><span class="line">         sum=i+sum;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(sum);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java基础&quot;&gt;&lt;a href=&quot;#java基础&quot; class=&quot;headerlink&quot; title=&quot;java基础&quot;&gt;&lt;/a&gt;java基础&lt;/h1&gt;&lt;p&gt;==（实时更新）==&lt;/p&gt;
&lt;h2 id=&quot;一-Collection&quot;&gt;&lt;a href=&quot;#一-Colle</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>spring</title>
    <link href="https://onedream666.github.io/2021/02/28/spring/"/>
    <id>https://onedream666.github.io/2021/02/28/spring/</id>
    <published>2021-02-28T10:19:53.000Z</published>
    <updated>2021-02-28T10:40:43.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring学习"><a href="#spring学习" class="headerlink" title="spring学习"></a>spring学习</h1><h2 id="1Spring概述"><a href="#1Spring概述" class="headerlink" title="1Spring概述"></a>1Spring概述</h2><h3 id="1-1Spring介绍"><a href="#1-1Spring介绍" class="headerlink" title="1.1Spring介绍"></a>1.1Spring介绍</h3><p>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) <a href="http://baike.baidu.com/subview/1318763/16205192.htm">轻量级</a>开源框架。</p><h4 id="1-1-1Spring作用"><a href="#1-1-1Spring作用" class="headerlink" title="1.1.1Spring作用"></a>1.1.1Spring作用</h4><p>Spring致力于提供一种方法管理你的<a href="http://baike.baidu.com/view/478351.htm">业务对象</a>。</p><p>Spring的主要目的是使JavaEE易用和促进好编程习惯。</p><p>Spring致力于J2EE应用的各层的解决方案，而不是仅仅专注于某一层的方案。可以说Spring是企业应用开发的“一站式”选择，并贯穿表现层、业务层及<a href="http://baike.baidu.com/view/198047.htm">持久层</a>。然而，Spring并不想取代那些已有的框架，而是与它们无缝地整合。</p><h4 id="1-1-2Spring起源"><a href="#1-1-2Spring起源" class="headerlink" title="1.1.2Spring起源"></a>1.1.2Spring起源</h4><p>Spring的出现是为了取代EJB（Enterprise JavaBean）的臃肿、低效、脱离现实的特点。</p><p>传统J2EE应用的开发效率低，<a href="http://baike.baidu.com/view/995472.htm">应用服务器</a>厂商对各种技术的支持并没有真正统一，导致J2EE的应用没有真正实现Write Once及Run Anywhere的承诺。Spring作为开源的中间件，独立于各种应用服务器，甚至无须应用服务器的支持，也能提供应用服务器的功能，如<a href="http://baike.baidu.com/view/1996549.htm">声明式事务</a>、事务处理等。</p><h3 id="1-2Spring体系结构"><a href="#1-2Spring体系结构" class="headerlink" title="1.2Spring体系结构"></a>1.2Spring体系结构</h3><p>Spring 框架是一个分层架构,,它包含一系列的功能要素并被分为大约20个模块。这些模块分为Core Container、Data Access/Integration、Web、AOP（Aspect Oriented Programming)、Instrumentation和测试部分,如下图所示：</p><p><img src="/2021/02/28/spring/clip_image002.jpg" alt="img"></p><h4 id="1-2-1核心容器-Core-Container"><a href="#1-2-1核心容器-Core-Container" class="headerlink" title="1.2.1核心容器(Core Container)"></a>1.2.1核心容器(Core Container)</h4><p>1：Core和Beans模块提供了Spring最基础的功能，提供IoC(控制反转)和DI(依赖注入)特性。这里的基础概念是BeanFactory，它提供对Factory模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置。</p><p>2：Context模块基于Core和Beans来构建，它提供了用一种框架风格的方式来访问对象，有些像JNDI注册表。Context封装包继承了beans包的功能，还增加了国际化（I18N）,事件传播，资源装载，以及透明创建上下文，例如通过servlet容器，以及对大量JavaEE特性的支持，如EJB、JMX。核心接口是ApplicationContext。</p><p>3：Expression Language，表达式语言模块，提供了在运行期间查询和操作对象图的强大能力。支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。</p><h4 id="1-2-2数据访问-集成部分-Data-Access-Integration"><a href="#1-2-2数据访问-集成部分-Data-Access-Integration" class="headerlink" title="1.2.2数据访问/集成部分(Data Access/Integration)"></a>1.2.2数据访问/集成部分(Data Access/Integration)</h4><p>1：JDBC模块，提供对JDBC的抽象，它可消除冗长的JDBC编码和解析数据库厂商特有的错误代码。</p><p>2：ORM模块，提供了常用的”对象/关系”映射API的集成层。 其中包括JPA、JDO、Hibernate 和 iBatis 。利用ORM封装包，可以混合使用所有Spring提供的特性进行”对象/关系”映射，如简单声明性 事务管理 。</p><p>3：OXM模块，提供一个支持Object和XML进行映射的抽象层，其中包括JAXB、Castor、XMLBeans、JiBX和XStream。</p><p>4：JMS模块，提供一套”消息生产者、消费者”模板用于更加简单的使用JMS，JMS用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p><p>5：Transaction模块，支持程序通过简单声明性 事务管理，只要是Spring管理对象都能得到Spring管理事务的好处，即使是POJO，也可以为他们提供事务。</p><h4 id="1-2-3Web"><a href="#1-2-3Web" class="headerlink" title="1.2.3Web"></a>1.2.3Web</h4><p>1：Web-Socket模块， WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，spring支持webSocket通信。</p><p>2：Web模块，提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问、以及Web Service支持，并提供一个RestTemplate类来提供方便的Restful services访问</p><p>3：Web-Servlet模块，提供了Web应用的Model-View-Controller（MVC）实现。Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的JSP标签，完全无缝与Spring其他技术协作。</p><p>4：Web-Portlet模块，提供了在Portlet环境下的MVC实现</p><p>5：spring本身提供springmvc</p><h4 id="1-2-4AOP"><a href="#1-2-4AOP" class="headerlink" title="1.2.4AOP"></a>1.2.4AOP</h4><p>1：AOP模块，提供了符合AOP 联盟规范的面向方面的编程实现，让你可以定义如方法拦截器和切入点，从逻辑上讲，可以减弱代码的功能耦合，清晰的被分离开。而且，利用源码级的元数据功能，还可以将各种行为信息合并到你的代码中 。</p><p>2：Aspects模块，提供了对AspectJ的集成。</p><p>3：Instrumentation模块， 提供一些类级的工具支持和ClassLoader级的实现，可以在一些特定的应用服务器中使用</p><h4 id="1-2-5Test"><a href="#1-2-5Test" class="headerlink" title="1.2.5Test"></a>1.2.5Test</h4><p>1：Test模块，提供对使用JUnit和TestNG来测试Spring组件的支持，它提供一致的ApplicationContexts并缓存这些上下文，它还能提供一些mock对象，使得你可以独立的测试代码。</p><h3 id="1-3Spring优点"><a href="#1-3Spring优点" class="headerlink" title="1.3Spring优点"></a>1.3Spring优点</h3><p>方便解耦，简化开发</p><p>Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理</p><p>AOP编程的支持</p><p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能</p><p>声明式事务的支持</p><p>只需要通过配置就可以完成对事务的管理，而无需手动编程方便程序的测试</p><p>Spring对Junit4支持，可以通过注解方便的测试Spring程序方便集成各种优秀框架</p><p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的直接支持降低JavaEE API的使用难度</p><p>Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低</p><h2 id="2IOC与DI"><a href="#2IOC与DI" class="headerlink" title="2IOC与DI"></a>2IOC与DI</h2><h3 id="2-1Spring的jar包下载"><a href="#2-1Spring的jar包下载" class="headerlink" title="2.1Spring的jar包下载"></a>2.1Spring的jar包下载</h3><p>Spring的官网:spring.io</p><p>我们使用的是spring的4.2.4版本</p><p><img src="/2021/02/28/spring/clip_image003.png" alt="img"></p><p>在spring3.0.2版本后,不再提供依赖jar包的下载</p><p><img src="/2021/02/28/spring/clip_image004.png" alt="img"></p><p>docs:存放的是API和规范文档</p><p>libs:开发的jar包</p><p>schema:开发过程中需要的xml文件的schema约束</p><h3 id="2-2Spring开发环境搭建"><a href="#2-2Spring开发环境搭建" class="headerlink" title="2.2Spring开发环境搭建"></a>2.2Spring开发环境搭建</h3><p>在spring的开发中,我们要根据不同的情况来导入不同的jar包,当前要学习的是关于ioc与di</p><p>对于ioc和di学习,我们只需要导入spring的核心功能jar包</p><p>beans core context spel相关</p><p><img src="/2021/02/28/spring/clip_image005.png" alt="img"></p><p>我们使用spring框架也需要使用配置文件,我们需要在src下创建一个关于spring的配置文件,一般情况下名称叫做applicationContext.xml</p><p>问题:applicationContext.xml的约束?</p><p><img src="/2021/02/28/spring/clip_image006.png" alt="img"></p><p>文件位置:</p><p>spring-framework-4.2.4.RELEASE-dist\spring-framework-4.2.4.RELEASE\docs\spring-framework-reference\html</p><?xml version=*"1.0"* encoding=*"UTF-8"*?><p>&lt;beans xmlns=<em>“<a href="http://www.springframework.org/schema/beans&quot;">http://www.springframework.org/schema/beans&quot;</a></em></p><p>  xmlns:xsi=<em>“<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a></em></p><p>  xmlns:context=<em>“<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a></em></p><p>  xmlns:aop=<em>“<a href="http://www.springframework.org/schema/aop&quot;">http://www.springframework.org/schema/aop&quot;</a></em></p><p>  xsi:schemaLocation=<em>“<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a></em></p><p>​    <em><a href="http://www.springframework.org/schema/beans/spring-beans.xsd">http://www.springframework.org/schema/beans/spring-beans.xsd</a></em></p><p>​    <em><a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a></em></p><p>​    <em><a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a></em></p><p>​    <em><a href="http://www.springframework.org/schema/aop">http://www.springframework.org/schema/aop</a></em></p><p>​    <em><a href="http://www.springframework.org/schema/aop/spring-aop.xsd&quot;">http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</a></em>&gt;</p><h3 id="2-3IOC快速入门"><a href="#2-3IOC快速入门" class="headerlink" title="2.3IOC快速入门"></a>2.3IOC快速入门</h3><p>ioc它是什么,解决什么问题,它的原始是如何实现</p><p>Ioc inverse of control 控制反转</p><p>Ioc简单来说,就是将原来由我们实例化的对象,交由spring框架来进行实例化.这是对象的实例化的权利就会反转.</p><p><img src="/2021/02/28/spring/clip_image007.png" alt="img"></p><p>原因:需要导入commons-logging的jar包</p><p>总结:spring的使用步骤</p><p>\1.   在applicationContext.xml文件中配置bean</p><p><img src="/2021/02/28/spring/clip_image009.jpg" alt="img"></p><p>\2.   创建一个applicationContext对象</p><p>applicationContext对象它是beanFactory的一个子接口,我们在使用的时候使用的是它的实现类classPathXmlApplicationContext</p><p><img src="/2021/02/28/spring/clip_image011.jpg" alt="img"></p><p>可以通过applicationContext对象的getBean(类名加载器或者配置文件中id名称)来获取指定的对象</p><p>==编程式使用IOC容器==</p><ol><li>创建Ioc配置文件的抽象资源，这个抽象资源包含了BeanDefinition的定义信息。</li><li>创建一个beanFactory</li><li>创建一个载入BeanDfinition的读取器，这里使用XMLBeanDefinitionReader对象来载入XML文件形式的BeanDefinition，通过一个回调配置给BeanFactory</li><li>从定以好的资源位置读入配置信息，具体的解析过程由XmlBeanDefinitionReader完成；完成整个载入 和注册Bean定义之后，需要的IoC容器就建立起来了。之后就可以使用IoC容器了</li></ol><h3 id="2-4DI"><a href="#2-4DI" class="headerlink" title="2.4DI"></a>2.4DI</h3><p>DI: dependency injection 依赖注入</p><p>在spirng框架负责创建bean对象时,动态的将依赖对象注入到bean组件中.</p><p><img src="/2021/02/28/spring/clip_image013.jpg" alt="img"></p><p><img src="/2021/02/28/spring/clip_image015.jpg" alt="img"></p><p>面试题:IOC和DI的区别?</p><p>IOC 控制反转,是指对象实例化权利交由spring容器来管理</p><p>DI  依赖注入 在spring创建bean对象过程中,动态的将对象所依赖的属性通过配置注入到对象中</p><h2 id="3Bean的属性注入"><a href="#3Bean的属性注入" class="headerlink" title="3Bean的属性注入"></a>3Bean的属性注入</h2><p>在spring中bean的属性注入有四种</p><p>构造器注入,setter注入,静态工厂注入,实例工厂注入</p><h3 id="3-1构造器注入"><a href="#3-1构造器注入" class="headerlink" title="3.1构造器注入"></a>3.1构造器注入</h3><p><img src="/2021/02/28/spring/clip_image017.jpg" alt="img"></p><h3 id="3-2Setter方法注入"><a href="#3-2Setter方法注入" class="headerlink" title="3.2Setter方法注入"></a>3.2Setter方法注入</h3><p><img src="/2021/02/28/spring/clip_image019.jpg" alt="img"></p><p>关于ref属性的作用</p><p><img src="/2021/02/28/spring/clip_image021.jpg" alt="img"></p><p>使用ref属性可以引入另一个bean对象,完成bean之间的注入</p><h2 id="4Spring注解开发"><a href="#4Spring注解开发" class="headerlink" title="4Spring注解开发"></a>4Spring注解开发</h2><p>在spring中使用注解,我们必须在applicationContext.xml文件中添加一个标签</p><p><a href="context:annotation-config/">context:annotation-config/</a>作用是让spring中常用的一些注解生效</p><p>要是用context名称空间,必须在applicationContext.xml文件汇总引入</p><p><img src="/2021/02/28/spring/clip_image023.jpg" alt="img"></p><h3 id="4-1完成bean的注册操作"><a href="#4-1完成bean的注册操作" class="headerlink" title="4.1完成bean的注册操作"></a>4.1完成bean的注册操作</h3><p>测试时报错</p><p><img src="/2021/02/28/spring/clip_image025.jpg" alt="img"></p><p>原因:如果你使用的是spring3.x版本那么不会出现这个错误,如果使用的是spring4.x版本会报错,原因是缺少jar包</p><p><img src="/2021/02/28/spring/clip_image026.png" alt="img"></p><p>导入jar包后运行还是有错误</p><p><img src="/2021/02/28/spring/clip_image028.jpg" alt="img"></p><p>我们需要在applicationContext.xml文件中使用了<a href="context:annotation-config/">context:annotation-config/</a>,它代表的是可以使用spring的注解,但是我们在类上添加的注解,spring不知道位置</p><p>要解决这个问题,我们可以使用&lt;context:component-scan base-package=”” /&gt;</p><p>在spring2.5后,为@Componet添加了三个衍生的注解</p><p>@Repository 用于dao层</p><p>@Service    用于service层</p><p>@Controller  用于表现层</p><p>对于我们的bean所处在的位置可以选择上述三个注解来应用,如果你的bean不明确位置,就可以使用@Component</p><h3 id="4-2属性的依赖注入"><a href="#4-2属性的依赖注入" class="headerlink" title="4.2属性的依赖注入"></a>4.2属性的依赖注入</h3><p>\1.   简单类型的属性注入</p><p><img src="/2021/02/28/spring/clip_image029.png" alt="img"></p><p>\2.   复杂的属性注入</p><p><img src="/2021/02/28/spring/clip_image030.png" alt="img"></p><p>注意:如果要扫描多个包下的注解可以写成</p><p><img src="/2021/02/28/spring/clip_image032.jpg" alt="img"></p><p>或</p><p><img src="/2021/02/28/spring/clip_image033.png" alt="img"></p><p>注意:@Value@Autowired 它们可以修饰属性,也可以修饰setter方法,如果写在属性上,就不需要提供setter方法</p><p>@Autowired它默认是根据类型进行注入</p><h2 id="5Spring-AOP"><a href="#5Spring-AOP" class="headerlink" title="5Spring AOP"></a>5Spring AOP</h2><h3 id="5-1AOP概述"><a href="#5-1AOP概述" class="headerlink" title="5.1AOP概述"></a>5.1AOP概述</h3><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：<a href="http://baike.baidu.com/view/1865230.htm">面向切面编程</a>，通过<a href="http://baike.baidu.com/view/176610.htm">预编译</a>方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是<a href="http://baike.baidu.com/view/63596.htm">OOP</a>的延续，是软件开发中的一个热点，也是<a href="http://baike.baidu.com/view/23023.htm">Spring</a>框架中的一个重要内容，是<a href="http://baike.baidu.com/view/1711147.htm">函数式编程</a>的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<a href="http://baike.baidu.com/view/1599212.htm">耦合度</a>降低，提高程序的可重用性，同时提高了开发的效率。</p><p>AOP是一个概念，并没有设定具体语言的实现，它能克服那些只有单继承特性语言的缺点，spring2.0之后整合AspectJ第三方AOP技术。</p><p>AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法所以它有一个专门的<a href="http://baike.baidu.com/view/487018.htm">编译器</a>用来生成遵守Java字节编码规范的Class文件。</p><h4 id="5-1-1主要功能"><a href="#5-1-1主要功能" class="headerlink" title="5.1.1主要功能"></a>5.1.1主要功能</h4><p>日志记录，性能统计，安全控制，事务处理，<a href="http://baike.baidu.com/view/1072586.htm">异常处理</a>等等</p><h4 id="5-1-2主要意图"><a href="#5-1-2主要意图" class="headerlink" title="5.1.2主要意图"></a>5.1.2主要意图</h4><p>将日志记录，性能统计，安全控制，事务处理，<a href="http://baike.baidu.com/view/1072586.htm">异常处理</a>等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。</p><p><strong>AOP与OOP区别</strong></p><p>OOP（<a href="http://baike.baidu.com/view/10110.htm">面向对象编程</a>）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的<a href="http://baike.baidu.com/view/1520672.htm">逻辑单元</a>划分。</p><p>而AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低<a href="http://baike.baidu.com/view/1731634.htm">耦合性</a>的隔离效果。这两种设计思想在目标上有着本质的差异。</p><p>换而言之，OOD/OOP面向名词领域，AOP面向动词领域。</p><h3 id="5-2AOP相关术语"><a href="#5-2AOP相关术语" class="headerlink" title="5.2AOP相关术语"></a>5.2AOP相关术语</h3><h4 id="5-2-1目标对象target"><a href="#5-2-1目标对象target" class="headerlink" title="5.2.1目标对象target"></a>5.2.1目标对象target</h4><p>指的是需要被增强的对象，由于spring aop是通过代理模式实现，从而这个对象永远是被代理对象。</p><h4 id="5-2-2连接点-join-point"><a href="#5-2-2连接点-join-point" class="headerlink" title="5.2.2连接点(join point)"></a>5.2.2连接点(join point)</h4><p>所谓连接点是指那些被拦截到的点，在spring中这些点指的是方法，因为spring只支持方法类型的连接点</p><h4 id="5-2-3切入点-pointcut"><a href="#5-2-3切入点-pointcut" class="headerlink" title="5.2.3切入点(pointcut)"></a>5.2.3切入点(pointcut)</h4><p>表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、<a href="http://baike.baidu.com/view/94238.htm">正则表达式</a>等方式集中起来，它定义了相应的 Advice 将要发生的地方</p><p>简单说切入点是指我们要对哪些连接点进行拦截的定义</p><h4 id="5-2-4通知-advice"><a href="#5-2-4通知-advice" class="headerlink" title="5.2.4通知(advice)"></a>5.2.4通知(advice)</h4><p>所谓通知是指拦截到连接点之后所要做的事情就是通知，通知分为前置通知，后置通知，异常通知，最终通知，环绕通知</p><p>Advice 定义了在 pointcut 里面定义的程序点具体要做的操作</p><h4 id="5-2-5引介introduction"><a href="#5-2-5引介introduction" class="headerlink" title="5.2.5引介introduction"></a>5.2.5引介introduction</h4><p>引介是一种特殊的通知，在不修改类代码的前提下，introduction可以在运行期为类动态地添加一些方法或属性</p><h4 id="5-2-6切面aspect"><a href="#5-2-6切面aspect" class="headerlink" title="5.2.6切面aspect"></a>5.2.6切面aspect</h4><p>是切入点和通知的结合</p><h4 id="5-2-7织入weaving"><a href="#5-2-7织入weaving" class="headerlink" title="5.2.7织入weaving"></a>5.2.7织入weaving</h4><p>织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期，类装载期，运行期进行。</p><p>Spring采用动态织入，而aspectj采用静态织入</p><h4 id="5-2-8代理Proxy"><a href="#5-2-8代理Proxy" class="headerlink" title="5.2.8代理Proxy"></a>5.2.8代理Proxy</h4><p>一个类被AOP织入增强后，就产生一个结果代理类</p><p><img src="/2021/02/28/spring/clip_image035.jpg" alt="img"></p><h3 id="5-4Spring-AOP编程"><a href="#5-4Spring-AOP编程" class="headerlink" title="5.4Spring AOP编程"></a>5.4Spring AOP编程</h3><h5 id="5-4-1关于切点表达式写法"><a href="#5-4-1关于切点表达式写法" class="headerlink" title="5.4.1关于切点表达式写法"></a>5.4.1关于切点表达式写法</h5><p><img src="/2021/02/28/spring/clip_image037.jpg" alt="img"></p><p>这个表达式的语法是源于aspectJ的语法,spring中的aop开发,对aspectJ不是完全支持,只支持部分语法.</p><p>在开发中使用的比较多的是excution语法</p><p>关于execution语法常用的有:</p><p>\1.   execution(public * *(..)) 所有的public的方法</p><p>\2.   execution(* com.spring.aop.*(..))所有的aop包下的所有类的方法(不包含子包)</p><p>\3.   execution(* com.spring.aop..*(..))所有的aop包及其子包下的所有类的方法.</p><p>\4.   execution(* com.spring.aop.IOrderService.*(..))IOrderService接口中定义的所有方法</p><p>\5.   execution(* com.spring.aop.IOrderService+.*(..))匹配实现特定接口所有类的方法</p><p>\6.   execution(* save*(..))去匹配所有以save开头的方法</p><h5 id="4-4-2基于xml配置方案"><a href="#4-4-2基于xml配置方案" class="headerlink" title="4.4.2基于xml配置方案"></a>4.4.2基于xml配置方案</h5><h6 id="第一步-创建目标-target"><a href="#第一步-创建目标-target" class="headerlink" title="第一步:创建目标(target)"></a>第一步:创建目标(target)</h6><p><img src="/2021/02/28/spring/clip_image039.jpg" alt="img"></p><h6 id="第二步-创建通知-增强-advice"><a href="#第二步-创建通知-增强-advice" class="headerlink" title="第二步:创建通知(增强 advice)"></a>第二步:创建通知(增强 advice)</h6><p>注意:在aspectJ中它的增强可以不实现任何接口,只需要定义出增强功能(方法)</p><p><img src="/2021/02/28/spring/clip_image041.jpg" alt="img"></p><h6 id="第三步-在spring的xml配置文件中来配置"><a href="#第三步-在spring的xml配置文件中来配置" class="headerlink" title="第三步:在spring的xml配置文件中来配置"></a>第三步:在spring的xml配置文件中来配置</h6><p><a href="aop:config">aop:config</a>下的<a href="aop:aspect">aop:aspect</a>是aspectJ框架用来声明切面的.</p><p><img src="/2021/02/28/spring/clip_image043.jpg" alt="img"></p><p>定义切入点</p><p><img src="/2021/02/28/spring/clip_image045.jpg" alt="img"></p><p>前置通知</p><p><img src="/2021/02/28/spring/clip_image047.jpg" alt="img"></p><p>后置通知</p><p><img src="/2021/02/28/spring/clip_image049.jpg" alt="img"></p><p>环绕通知</p><p><img src="/2021/02/28/spring/clip_image051.jpg" alt="img"></p><p><img src="/2021/02/28/spring/clip_image053.jpg" alt="img"></p><p>异常抛出:</p><p><img src="/2021/02/28/spring/clip_image054.png" alt="img"></p><p>注意:目标行为只有抛出了异常之后才会执行这个增强方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;spring学习&quot;&gt;&lt;a href=&quot;#spring学习&quot; class=&quot;headerlink&quot; title=&quot;spring学习&quot;&gt;&lt;/a&gt;spring学习&lt;/h1&gt;&lt;h2 id=&quot;1Spring概述&quot;&gt;&lt;a href=&quot;#1Spring概述&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hello-world</title>
    <link href="https://onedream666.github.io/2021/02/28/hello-world/"/>
    <id>https://onedream666.github.io/2021/02/28/hello-world/</id>
    <published>2021-02-28T10:19:52.000Z</published>
    <updated>2021-02-28T10:40:30.719Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
